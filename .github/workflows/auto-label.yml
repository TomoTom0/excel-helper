name: Auto Label PR

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  pull-requests: write
  contents: read

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-label based on branch name
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const branchName = context.payload.pull_request.head.ref;
            const prTitle = context.payload.pull_request.title;
            const prBody = context.payload.pull_request.body || '';
            
            const labelsToAdd = [];
            
            // ブランチ名からラベル推論
            if (branchName.startsWith('feat/') || branchName.startsWith('feature/')) {
              labelsToAdd.push('type/feature', 'version/minor');
            } else if (branchName.startsWith('fix/')) {
              labelsToAdd.push('type/fix', 'version/patch');
            } else if (branchName.startsWith('docs/')) {
              labelsToAdd.push('type/docs', 'version/patch');
            } else if (branchName.startsWith('refactor/')) {
              labelsToAdd.push('type/refactor', 'version/patch');
            } else if (branchName.startsWith('test/')) {
              labelsToAdd.push('type/test');
            } else if (branchName.startsWith('ci/')) {
              labelsToAdd.push('type/ci');
            } else if (branchName.startsWith('chore/')) {
              labelsToAdd.push('type/chore');
            } else if (branchName.startsWith('hotfix/')) {
              labelsToAdd.push('type/fix', 'version/patch', 'priority/high');
            } else if (branchName.startsWith('breaking/')) {
              labelsToAdd.push('version/major');
            }
            
            // PRタイトルから破壊的変更を検出
            if (prTitle.includes('!:') || prTitle.toLowerCase().includes('breaking')) {
              labelsToAdd.push('version/major');
            }
            
            // PRテンプレートのチェックボックスから推論
            if (prBody.includes('[x] 🚀 新機能')) {
              labelsToAdd.push('type/feature', 'version/minor');
            }
            if (prBody.includes('[x] 🐛 バグ修正')) {
              labelsToAdd.push('type/fix', 'version/patch');
            }
            if (prBody.includes('[x] 📝 ドキュメント')) {
              labelsToAdd.push('type/docs', 'version/patch');
            }
            if (prBody.includes('[x] ♻️ リファクタリング')) {
              labelsToAdd.push('type/refactor', 'version/patch');
            }
            if (prBody.includes('[x] ⚠️ 破壊的変更')) {
              labelsToAdd.push('version/major');
            }
            if (prBody.includes('[x] ✅ テスト')) {
              labelsToAdd.push('type/test');
            }
            if (prBody.includes('[x] 🔧 CI/CD')) {
              labelsToAdd.push('type/ci');
            }
            if (prBody.includes('[x] 🧹 雑務')) {
              labelsToAdd.push('type/chore');
            }
            
            // バージョンラベルの優先度処理（major > minor > patch）
            const versionLabels = labelsToAdd.filter(l => l.startsWith('version/'));
            if (versionLabels.length > 1) {
              if (versionLabels.includes('version/major')) {
                labelsToAdd.splice(labelsToAdd.indexOf('version/minor'), 1);
                labelsToAdd.splice(labelsToAdd.indexOf('version/patch'), 1);
              } else if (versionLabels.includes('version/minor')) {
                labelsToAdd.splice(labelsToAdd.indexOf('version/patch'), 1);
              }
            }
            
            // 重複削除
            const uniqueLabels = [...new Set(labelsToAdd)];
            
            if (uniqueLabels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: uniqueLabels
              });
              
              console.log(`Added labels: ${uniqueLabels.join(', ')}`);
            } else {
              console.log('No labels to add');
            }
